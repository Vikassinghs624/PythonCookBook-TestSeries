# -*- coding: utf-8 -*-
"""PythonCookTestSeries: Data Structures and Algorithms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mty25m6vf-p_auXDIKj2IRZIrZtJSgJL
"""

p,r = (4,5)
print(p)
print(r)

data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
 dat,v,g,k = data
 print(k[0])

print("my name is vikas with ",4.5," Year of experince")

record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
name,email,*phone = record
print(name)
print(email)
print(phone[0])

*trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
quarter_avg = sum(trailing)/len(trailing)
print(quarter_avg)
print(current)
print(quarter_avg-current)

records = [
 ('foo', 1, 2),
 ('bar', 'hello'),
 ('foo', 3, 4),
]
def do_foo(x, y):
 print('foo', x, y)
def do_bar(s):
 print('bar', s)
for tag,*args in records:
  if tag =="foo":
    do_foo(*args)
  elif tag =="bar":
    do_bar(*args)

line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
uname, *fields, homedir, sh = line.split(':')
print(uname)
print(homedir)
print(sh)
print(fields)



production =[1,2,3,4,5,65]
production.pop(-1)
production

from collections import deque
def search(lines, pattern, history=5):
 previous_lines = deque(maxlen=history)
 for line in lines:
  if pattern in line:
    yield line, previous_lines
 previous_lines.append(line)

from collections import deque
q = deque(maxlen =3)
q.append(1)
q.append(2)
q.append(3)
print(q)
q.append(4)
q.append(5)
q.pop()
print(q)

pip install heapq
import heapq
nums =[1,8,2,23,7,-4,18,23,42,37,2]
print(heapq.nlargest(3,nums))
print(heaps.nsmallest(3,nums))

import heapq
my_list = [-15, -26, 15, 1, 23, -64, 23, 76]
heap = list(my_list)
heapq.heapify(heap)
print(heap)
heapq.heappop(heap)
heapq.heappop(heap)
heapq.heappop(heap)
heapq.heappop(heap)

from collections import defaultdict
d = defaultdict(list)
d['a'].append(1)
d['b'].append(2)
d['c'].append(3)

print(d)

d = {} # A regular dictionary
d.setdefault('a', []).append(1)
d.setdefault('a', []).append(2)
d.setdefault('b', []).append(4)
print(d)

##1.9. Finding Commonalities in Two Dictionaries
'''You have two dictionaries and want to find out what they might have in common (same
keys, same values, etc.).'''
a = {
 'x' : 1,
 'y' : 2,
 'z' : 3
}
b = {
 'w' : 10,
 'x' : 11,
 'y' : 2
}
#find keys in common
print(a.keys() & b.keys())
#find keys in a that are not in b
print(a.keys()-b.keys())
#find (key, value) paris in common
print(a.items() & b.items())
## Make a new dictionary with certain keys removed
c ={key:a[key] for key in a.keys()-{'z','w'}}
print(c)

#1.10. Removing Duplicates from a Sequence while Maintaining Order
#Problem: You want to eliminate the duplicate values in a sequence, but preserve the order of the remaining items.
a = [1, 5, 2, 1, 9, 1, 5, 10]
l =[]
for i in a:
  if i not in l:
    l.append(i)

print(l)
print(set(a))#this approach does not preserve any kind of ordering

#1.11. Naming a Slice
#Your program has become an unreadable mess of hardcoded slice indices and you want to clean it up.
items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2,4)
items[a]
a =slice(10,50,2)
a.start#return:10
a.stop#return :50
a.step#return :2
s = "VikasSikarwar"
print(a.indices(len(s)))

#1.12. Determining the Most Frequently Occurring Items in a Sequence
#Problem: Problem: You have a sequence of items, and you’d like to determine the most frequently occurring items in the sequence.
words = [
 'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
 'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
 'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
 'my', 'eyes', "you're", 'under'
]
from collections import Counter
word_counts = Counter(words)
# Counter is a dictionary that maps the items to the number of occurrences.
top_three = word_counts.most_common(3)
print(word_counts['not'])
print(top_three)

#1.13. Sorting a List of Dictionaries by a Common Key using  module’s itemgetter function
#You have a list of dictionaries and you would like to sort the entries according to one or more of the dictionary values
rows = [
 {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
 {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
 {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
 {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
from operator import itemgetter
rows_by_fname = sorted(rows,key = itemgetter('fname'))
rows_by_uid = sorted(rows,key=itemgetter('uid'))
print(rows_by_fname)
print(rows_by_uid)
rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)

#The functionality of itemgetter() is sometimes replaced by lambda expressions
rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
print(rows_by_fname)
print(rows_by_lfname)

#1.14. Sorting Objects Without Native Comparison Support
#Problem: You want to sort objects of the same class, but they don’t natively support compariso operations.

class User:
  def __init__(self,user_id):
    self.user_id = user_id
  def __repr__(self):
    return 'User({})'.format(self.user_id)
users =[User(23),User(99),User(50)]
print(sorted(users,key =lambda u: u.user_id))

#Instead of using lambda, an alternative approach is to use operator.attrgetter():
from operator import attrgetter
print(sorted(users,key=attrgetter('user_id')))
print(min(users, key=attrgetter('user_id')))
print(max(users, key=attrgetter('user_id')))

#1.15. Grouping Records Together Based on a Field
#Problem: You have a sequence of dictionaries or instances and you want to iterate over the data in groups based on the value of a particular field, such as date
# The itertools.groupby() function is particularly useful for grouping data together like this
rows = [
 {'address': '5412 N CLARK', 'date': '07/01/2012'},
 {'address': '5148 N CLARK', 'date': '07/04/2012'},
 {'address': '5800 E 58TH', 'date': '07/02/2012'},
 {'address': '2122 N CLARK', 'date': '07/03/2012'},
 {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
 {'address': '1060 W ADDISON', 'date': '07/02/2012'},
 {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
 {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
from operator import itemgetter
from itertools import groupby
# Sort by the desired field first
rows.sort(key=itemgetter('date'))
# Iterate in groups
for date,items in groupby(rows,key=itemgetter('date')):
  print(date)
  for i in items:
    print(' ',i)

#1.16. Filtering Sequence Elements
#problem: You have data inside of a sequence, and need to extract values or reduce the sequence using some criteria
mylist = [1, 4, -5, 10, -7, 2, 3, -1]
clip_neg = [n if n > 0 else 0 for n in mylist]
print(clip_neg)
l1= [i for i in mylist if i>0]
print(l1)
#a list comprehension is that it might produce a large result if the original input is large so you can use generator expressions to produce the filtered values iteratively
values = ['1', '2', '-3', '-', '4', 'N/A', '5']
def is_int(val):
  try:
    a = int(val)
    return True
  except ValueError:
    return False

ivals = list(filter(is_int,values))
print(ivals)

from itertools import compress
addresses = [
 '5412 N CLARK',
 '5148 N CLARK',
 '5800 E 58TH',
 '2122 N CLARK'
 '5645 N RAVENSWOOD',
 '1060 W ADDISON',
 '4801 N BROADWAY',
 '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
l1= [n>5 for n in counts]
print(l1)
list_m = list(compress(addresses,l1))
print(list_m)

'''The key here is to first create a sequence of Booleans that indicates which elements
satisfy the desired condition. The compress() function then picks out the items corre‐
sponding to True values.
Like filter(), compress() normally returns an iterator. Thus, you need to use list()
to turn the results into a list if desired.'''

#1.17. Extracting a Subset of a Dictionary
#Problem:You want to make a dictionary that is a subset of another dictionary
prices = {
 'ACME': 45.23,
 'AAPL': 612.78,
 'IBM': 205.55,
 'HPQ': 37.20,
 'FB': 10.75
}

## Make a dictionary of all prices over 200
price_more_200 = { key:prices[key] for key in prices.keys() if prices[key] > 200}
print(price_more_200)

#1.18. Mapping Names to Sequence Elements
#Problem: You have code that accesses list or tuple elements by position, but this makes the code
# somewhat difficult to read at times. You’d also like to be less dependent on position in
# the structure, by accessing the elements by name
from collections import namedtuple
subscriber =namedtuple('subscribe',['addr','joined'])
sub = subscriber("vikassingh@gmail.com","1995-08-10")
print(sub)
print(sub.addr)
print(sub.joined)
Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
stock_prototype = Stock('', 0, 0.0, None, None)
def dict_to_stock(s):
 return stock_prototype._replace(**s)
a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
print(dict_to_stock(a))

#1.19. Transforming and Reducing Data at the Same Time
#You need to execute a reduction function (e.g., sum(), min(), max()), but first need to transform or filter the data.import os
# files = os.listdir('C:\Users\vikas')
# if any(name.endswith('.py') for name in files):
#  print('There be python!')
# else:
#  print('Sorry, no python.')
nums = [1, 2, 3, 4, 5]
s = sum([x * x for x in nums])
print(s)

#1.20. Combining Multiple Mappings into a Single Mapping
''' Problem: You have multiple dictionaries or mappings that you want to logically combine into a
single mapping to perform certain operations, such as looking up values or checking
for the existence of keys'''
a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }

from collections import ChainMap


c = ChainMap(a,b)
print(c['x'])
print(c['z'])
print(c['y'])
print(len(c))
print(list(c.keys()))
print(list(c.values()))
print(list(c.items()))
values = ChainMap()
values['x'] = 1
values =values.new_child()
values['x'] = 2
print(values)

merged = dict(b)
merged.update(a)
merged['z']

#